**[학습과제 제출 - B반 노설]**

▶1주차(3월25일~3월29일 11시59분PM) - "마이크로서비스를 위한 자바"-복습
교육생 문의가 많아 전체 공지드립니다. 교재 전체 단원 안 하셔도 되고, 복습인 만큼 본인이 취약한 부분, 미흡하다고 생각하는 단원들을 집중적으로 공부하시고 결과물을 제출해주시면 됩니다.

---

1. Java 배열 (5/6) : for-each

   + 배열에 담겨있는 것을 탐색하면서 반복시킬 때 사용함. 간결.

   + ```java
     String[] members = {"가나다", "라마바", "사아자"};
     for(String e : members){
     	System.out.println(e + "이 상담을 받았습니다.");
     }
     ```

 2. Java 배열(6/6): 배열의 오류와 한계

    + 인덱스에 없는 값을 출력을 할 시에 해당 오류가 발생한다.

      ```java
      Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10 at example1.main(example1.java:8)
      ```

    + 초기에 설정한 배열의 크기보다 넘치게 값을 추가 했을때 오류가 발생한다.

    + 배열의 한계

      + 배열은 초기화 할 때 크기를 미리 선언하고 정해진 크기 만큼까지만 데이터를 넣을 수 있다. 유연성이 떨어진다.
      + 자바에 컬렉션(Collection 또는 컨테이너)이라는 기능을 통해 배열의 한계를 유연하게 만들 수 있다. 편리하게 데이터를 핸들링 할 수 있다.

3. Java 메소드(1/6): 메소드 오리엔테이션

   + method, function, **함수**라 말한다. 자바: method 타 언어: 함수

     ```java
     public static void main(String[] args){}
     ```

4. Java 메소드(2/6): 메소드의 정의와 호출 (define과 call)

   ```java
   public class MethodDemo1{
   	public static void numbering(){
   	int i = 0;
   	while(i<10){
   		System.out.println(i);
   		i++;
   		}
   	}
   	public static void main(String[] args){
   		numbering(); 
           // 위의 numbering()이라는 이름을 가지고있는 이 메소드를 
           // 호출하여 사용할 수 있다.
   	}
   }
   ```

5. Java 메소드(3/6): 메소드가 없다면?

   + 이미 정의해 논 로직을 **재활용** 할 수 있음. -> **코드의 간소화**, **유지보수 용이**

6. Java 메소드(6/6): 복잡하게 데이터를 리턴하는 이유는?

   + **결론: 메소드(함수) 부품으로서의 가치를 높이기 위해서_ 강의내용**

   + 결과 값을 파일, 이메일, 화면에 출력하라는 식으로 요건을 바꾸게 된다면, 그에 맞추어 매번 `System.out.print`를 사용해 출력하면 번거롭고 어렵다.

     ```java
     try{//무시
         // out.txt라는 파일에 numbering이라는 메소드가 반환한 값을 
         // 저장
         BufferedWritter out = new BufferedWritter(new FileWriter("out.txt"));
         out.write(result);
         out.close();
     }catch (IOException e){
     } // 무시;
     ```

     => 실행 시 root 디렉토리에 `out.txt`라는 파일이 생성됨을 확인할 수 있다.

   + **배열 메소드의 리턴**

     ```java
     public class ReturnDemo4{
     	public static String[] getMembers(){ 
             //getMembers가 리턴하는 값이 문자열이라고 선언
             
     		String[] members = {"가나다", "라마바","사아자"};
     		return members;
     	}
     	
     	public static void main(String[] args){
     		String[] members = getMembers();
     	}
     }
     ```

7. Java 객체 지향 프로그래밍(3/3): 추상화- abstract 부품화-module

   + OOP(Object Oriented Programing)
   + 추상화 -> 지도 내의 지하철 선로 모습 -> ... -> 지하철 노선도
   + 객체 = 변수와 메소드를 grouping 한 것. 또 이를 일종의 부품이 된다.
   + 부품화 = 재활용

8. Java 클래스와 인스턴스 그리고 객체지향(5/5): 객체화

   + instance: 설계도에 따라 만들어진 구체적인 제품들

     ***Calculator c1 = new Calculator();*** 

     ***Calculator c2 = new Calculator();*** 

   + class: 설계도  

     ***class Caculator***

     > **class라는 설계도는 new사용해서 선언. => 객체가 만들어짐 = 인스턴스**
     >
     > 그리고 class 내부적으로 변수를 가지고 있다.

   + 상태(state)와 행동(behave)

     + 변수: 상태	메소드:행동

     + 블로그의 문장을 그대로 붙임

       > 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다는 것을 알 수 있다.

       하나의 클래스가 여러개의 인스턴스가 될수 있다는 점이 객체 지향이 제공하는 가장 기본적인 **재활용성**

9. Java 클래스 멤버, 인스턴스 멤버(4/4): 멤버란?

   + 인스턴스 변수:  Non-Static Field

   + 클래스 변수: Static Field

   + 각각 클래스 멤버와 인스턴스 멤버안에는 변수와 메소드가 들어있다.

     + **클래스 메소드를 선언할 때는 반드시 `static`과 선언한다.**

     ```java
     class Calculator{ }
     public class CalculatorDemo1{
     	public static void main(String[] args){
     		Calculator c1 = new Calculator();
     		System.out.println(c1.PI);
     		//c1 인스턴스 생성 후 출력
             
     		Calculator c2 = new Calculator();
     		System.out.println(c2.PI);
     		//c2 인스턴스 생성 후 출력		
     		
     		System.out.println(Calculator.PI);
     		//클래스를 통해 직접적으로 접근이 가능
             
             //결국 위의 두개 인스턴스와 클래스 접근을 통한 출력 3.14 로 출력된다.
     	}
     }
     ```

   + 클래스로 접근한 후에 인스턴스 출력할 때,

     ```java
     class Calculator2{
         static double PI = 3.14;
         static int base = 0;
         int left,right;
     
         public void setOprands(int left, int right){
             this.left = left;
             this.right = right;
         }
         
     	public void sum(){
             System.out.println(this.left + this.right + base);
         }
     	public static void main(String[] args){
     		Calculator c1 = new Calculator2();
     		c1.setOprands(10,20);
     		//30출력
     		c1.sum();
     		
     		Calculator c2 = new Calculator2();
     		c2.setOprands(20,40);
     		//60출력
     		c2.sum();		
         
         	//클래스 변수 base의 값을 10으로 지정
         	Calculator2.base =10;
         
         	c1.sum(); //40 출력
         
         	c2.sum(); //70 출력
     	}
     }
     ```

10. Java 유효범위(1/4): 유효범위란?

    + 

---

(참고 페이지)

1. 블로그 https://opentutorials.org/
2. 유튜브 https://youtu.be/Yu49BOJueaw

