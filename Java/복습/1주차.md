**[학습과제 제출 - B반 노설]**

▶1주차(3월25일~3월29일 11시59분PM) - "마이크로서비스를 위한 자바"-복습
교육생 문의가 많아 전체 공지드립니다. 교재 전체 단원 안 하셔도 되고, 복습인 만큼 본인이 취약한 부분, 미흡하다고 생각하는 단원들을 집중적으로 공부하시고 결과물을 제출해주시면 됩니다.

---

1. Java 배열 (5/6) : for-each

   + 배열에 담겨있는 것을 탐색하면서 반복시킬 때 사용함. 간결.

   + ```java
     String[] members = {"가나다", "라마바", "사아자"};
     for(String e : members){
     	System.out.println(e + "이 상담을 받았습니다.");
     }
     ```

 2. Java 배열(6/6): 배열의 오류와 한계

    + 인덱스에 없는 값을 출력을 할 시에 해당 오류가 발생한다.

      ```java
      Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10 at example1.main(example1.java:8)
      ```

    + 초기에 설정한 배열의 크기보다 넘치게 값을 추가 했을때 오류가 발생한다.

    + 배열의 한계

      + 배열은 초기화 할 때 크기를 미리 선언하고 정해진 크기 만큼까지만 데이터를 넣을 수 있다. 유연성이 떨어진다.
      + 자바에 컬렉션(Collection 또는 컨테이너)이라는 기능을 통해 배열의 한계를 유연하게 만들 수 있다. 편리하게 데이터를 핸들링 할 수 있다.

3. Java 메소드(1/6): 메소드 오리엔테이션

   + method, function, **함수**라 말한다. 자바: method 타 언어: 함수

     ```java
     public static void main(String[] args){}
     ```

4. Java 메소드(2/6): 메소드의 정의와 호출 (define과 call)

   ```java
   public class MethodDemo1{
   	public static void numbering(){
   	int i = 0;
   	while(i<10){
   		System.out.println(i);
   		i++;
   		}
   	}
   	public static void main(String[] args){
   		numbering(); 
           // 위의 numbering()이라는 이름을 가지고있는 이 메소드를 
           // 호출하여 사용할 수 있다.
   	}
   }
   ```

5. Java 메소드(3/6): 메소드가 없다면?

   + 이미 정의해 논 로직을 **재활용** 할 수 있음. -> **코드의 간소화**, **유지보수 용이**

6. Java 메소드(6/6): 복잡하게 데이터를 리턴하는 이유는?

   + **결론: 메소드(함수) 부품으로서의 가치를 높이기 위해서_ 강의내용**

   + 결과 값을 파일, 이메일, 화면에 출력하라는 식으로 요건을 바꾸게 된다면, 그에 맞추어 매번 `System.out.print`를 사용해 출력하면 번거롭고 어렵다.

     ```java
     try{//무시
         // out.txt라는 파일에 numbering이라는 메소드가 반환한 값을 
         // 저장
         BufferedWritter out = new BufferedWritter(new FileWriter("out.txt"));
         out.write(result);
         out.close();
     }catch (IOException e){
     } // 무시;
     ```

     => 실행 시 root 디렉토리에 `out.txt`라는 파일이 생성됨을 확인할 수 있다.

   + **배열 메소드의 리턴**

     ```java
     public class ReturnDemo4{
     	public static String[] getMembers(){ 
             //getMembers가 리턴하는 값이 문자열이라고 선언
             
     		String[] members = {"가나다", "라마바","사아자"};
     		return members;
     	}
     	
     	public static void main(String[] args){
     		String[] members = getMembers();
     	}
     }
     ```

7. Java 객체 지향 프로그래밍(3/3): 추상화- abstract 부품화-module

   + OOP(Object Oriented Programing)
   + 추상화 -> 지도 내의 지하철 선로 모습 -> ... -> 지하철 노선도
   + 객체 = 변수와 메소드를 **grouping** 한 것. 또 이를 일종의 부품이 된다.
   + 부품화 = 재활용

8. Java 클래스와 인스턴스 그리고 객체지향(5/5): 객체화

   + instance: 설계도에 따라 만들어진 구체적인 제품들

     ***Calculator c1 = new Calculator();*** 

     ***Calculator c2 = new Calculator();*** 

   + class: 설계도  

     ***class Caculator***

     > **class라는 설계도는 new사용해서 선언. => 객체가 만들어짐 = 인스턴스**
     >
     > 그리고 class 내부적으로 변수를 가지고 있다.

   + 상태(state)와 행동(behave)

     + 변수: 상태	메소드:행동

     + 블로그의 문장을 그대로 붙임

       > 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다는 것을 알 수 있다.

       하나의 클래스가 여러개의 인스턴스가 될수 있다는 점이 객체 지향이 제공하는 가장 기본적인 **재활용성**

9. Java 클래스 멤버, 인스턴스 멤버(4/4): 멤버란?

   + 인스턴스 변수:  Non-Static Field

   + 클래스 변수: Static Field

   + 각각 클래스 멤버와 인스턴스 멤버안에는 변수와 메소드가 들어있다.

     + **클래스 메소드를 선언할 때는 반드시 `static`과 선언한다.**

     ```java
     class Calculator{ }
     public class CalculatorDemo1{
     	public static void main(String[] args){
     		Calculator c1 = new Calculator();
     		System.out.println(c1.PI);
     		//c1 인스턴스 생성 후 출력
             
     		Calculator c2 = new Calculator();
     		System.out.println(c2.PI);
     		//c2 인스턴스 생성 후 출력		
     		
     		System.out.println(Calculator.PI);
     		//클래스를 통해 직접적으로 접근이 가능
             
             //결국 위의 두개 인스턴스와 클래스 접근을 통한 출력 3.14 로 출력된다.
     	}
     }
     ```

   + 클래스로 접근한 후에 인스턴스 출력할 때,

     ```java
     class Calculator2{
         static double PI = 3.14;
         static int base = 0;
         int left,right;
     
         public void setOprands(int left, int right){
             this.left = left;
             this.right = right;
         }
         
     	public void sum(){
             System.out.println(this.left + this.right + base);
         }
     	public static void main(String[] args){
     		Calculator c1 = new Calculator2();
     		c1.setOprands(10,20);
     		//30출력
     		c1.sum();
     		
     		Calculator c2 = new Calculator2();
     		c2.setOprands(20,40);
     		//60출력
     		c2.sum();		
         
         	//클래스 변수 base의 값을 10으로 지정
         	Calculator2.base =10;
         
         	c1.sum(); //40 출력
         
         	c2.sum(); //70 출력
     	}
     }
     ```

10. Java 유효범위(4/4): 유효범위란?, 인스턴스의 유효범위 `scope`

    + 프로그램이 커지면 여러가지 이유로 이름이 겹칠 수 있다. 이를 해결하기 위한 것이 유효범위 = `scope` = 암시적인 기능

    +  
      [유효범위 코드]: https://github.com/SeolRoh/TIL/blob/master/Java/%EB%B3%B5%EC%8A%B5/ScopeDemo.java	"ScopeDemo.java"

    + ##### 클래스 아래에서 선언된 변수는 클래스 전역에 영향을 미친다. 

    + ##### 하지만, 메소드 내에서 선언된 변수는 클래스 아래에서 선언된 변수보다 우선순위가 높다. 

    + ##### 즉, 지역 보다 전역이 우선순위가 높다.

      + ```java
        public class ScopeDemo4{
        	static void a(){
        		String title = "coding everybody";
        	}
        	public static void main(String[] args){
        		a();
        		//System.out.pringln(title);
        	}
        }
        ```

      + 위의 코드 속 주석처리를 해제한다면 오류가 발생한다. 해당 title이라는 변수는 메소드 a에 있는 변수이기 때문에 해당 지역변수 내에서만 접근이 가능하기 때문이다.

      + ```java
        public class ScopeDemo6 {
            static int i = 5;
        
            static  void  a(){
                int i = 10;
                b();
            }
        
            static void b(){
                System.out.println(i);
            }
            public static void main(String[] args) {
                a();
            }
        }
        ```

      +  결과는 10이 아닌 5

      +  메소드 b 내에 지역변수가 있지 않은 한 전역변수 i인 5가 호출된다.

      + 이런 방식을 정적 스코프(static scope) 또는 lexical scope라고 부른다. `사용되는 시점에서의 유효범위 (메소드 a의 i) X` `정의된 시점에서의 유효범위 (i=5)` 사용 ##### 내생각에는 그냥 우선순위로 정의된 순서가 우선... 인듯하다.

      + 동적 스코프도 있지만 대부분의 언어들이 정적 스코프 방식을 이용한다고 한다.

      + 참고 https://opentutorials.org/module/516/5447

    + **인스턴스의 유효범위 `this`** ------------------------------------------------------

      + ```java
        class C {
        	int v = 10;
        	
        	void m() {
                //int v =20;
        		System.out.println(v);
                //	// System.out.println(this.v)
        	}
        }
        public class ScopeDemo7{
        	public static void main(String[] args){
        		C c1 = new C();
        		c1.m();
        	}
        }
        ```

        결과 :  10

        주석을 제거했을 경우 결과: 20

        이유 :  메소드 m 의 지역변수인 v가 인스턴스 전역에서 유효한 인스턴스 변수 v 보다 우선순위가 높다.

        여기서 인스턴스 변수 v에 접근하려면 `this`를 사용하면 된다.

        **`this`는 인스턴스 자신을 의미하는 키워드 자체**

11. 상속(1/3):상속의 개념

    + 상속(Inheritance)란 기존에 있던 객체(변수,메소드)를 이어받으면서 기존에 있던것을 변경(수정)하거나 사용할 수 있는 것이 상속.
    + 재활용성, 중복의 최소화, 유지보수의 편의성

12. 상속과 생성자(1/2):기본생성자, super

    + 자기 자신을 main()에서 인스턴스 화 할수 있다.
    + 하위클래스에서 super(left,right); // 이경우 부모클래스 내의 매개변수가 두개인 생성자를 호출한다. 
    + super는 부모클래스를 의미한다. <u>**super사용시 가장 먼저 사용한다음에 초기화해야한다.**</u>
    + **하위클래스에서 상위클래스를 참조할수 있는 방법**

13. 오버라이딩(1/2):창의적인상속 `재정의`

    + 부모클래스의 기능을 변경할 수 있는 메소드 오버라이딩
    
    + 상속은 상위클래스의 기능을 하위 클래스에게 물려주는 기능이다. => 하위클래스는 상위클래스의 메소드를 있는 그대로 사용해야한다 => 이 제약을 벗어나기 위해 만들어진 **오버라이딩**
    
    + 부모클래스와 자식클래스 안에 같은 이름의 생성자 가 존재할시 우선순위가 하위로 간다.
    
      ```java
      class Calculator {
          int left;
          int right;
      
          void setOperands(int left, int right) {
              this.left = left;
              this.right = right;
          }
      
          public void add(){
              System.out.println(left-right);
          }
          public int avg() {
              return ((this.left + this.right) / 2);
          }
      }
      class substractionableCalculator extends Calculator{
          int substract(){
              return left - right;
          }
          public void add(){
              System.out.println("결과는 " + (left-right) );
          }
          public int avg() {
              return super.avg(); //중복을 최소화하기 위해 리턴값에 super()사용
          }
      }
      
      public class CalculatorDemo {
          public static void main(String[] args) {
              int result;
      
              substractionableCalculator a1 = new substractionableCalculator();
              //자식클래스로 인스턴스 변수 생성
              a1.setOperands(10,20);
              a1.add();
              System.out.println("실행 결과는" + a1.avg());
          }
      }
      ```
    
14. 오버로딩(1/2):오버로딩의 규칙

    + 가장 중요한건 매개변수!
    + 상속의 관계에서도 오버로딩을 사용할수 있다.

---

(참고 페이지)

1. 블로그 https://opentutorials.org/
2. 유튜브 https://youtu.be/Yu49BOJueaw

