데이터 모델과 성능 - 정규화

---

1. 정규화

   : 데이터의 일관성, 최소 중복, 최대 유연성을 요구함

   : 이로써 독립성 확보

   : 데이터 모델 변경을 최소화

   : 제 12345정규화 존대

2. 이상현상 : anomaly

3. 제1정규화

   : 속성 Attribute의 원자성 확보

   : 기본키를 설정

4. 제2정규화

   : 기본키가 2개이상의 Attribute로 이루어진다면, *부분 함수 종속성을 분해

   : 부분함수 종속성 제거

5. 제3정규화

   : 기본키를 제외한 칼럼간의 종속성을 제거함

   : 이행함수의 종속성 제거

6.  BCNF

   : 기본키를 제외한 후보키가 있는경우, 후보키가 기본키를 종속시키며 분해함

7. 제4정규화

   : 여러 칼럼들이 하나의 칼럼을 종속시키는 경우, 분해해서 다중값 속성을 제거

8. 제5정규화

   : 조인에 의해서 종속성이 발생하는 경우, 분해함

9. 정규화의 문제점

   : 정규화는 SELECT시 Join을 유발한다. CPU메모리를 많이 사용함.

   : 중첩된 Loop ( Nested Loops)

   : 결론

   + 조인이 부하를 유발

   : 해결

   + 반정규화 
     + 하나의 Table에 저장 ==> 성능저하 해결
     + 단 반정규화를 하면 데이터의 중복 발생 ==> 또다른 문제 발생
     + 한개의 행을 읽기 위해 여러개의 블록을 읽게 되고 DISK IO가 증가해 성능 감소.
   + 입출력 데이터의 양이 적으면 성능이 좋아짐 ==> 정규화
   + 하나의 테이블에 저장해 JOIN을 유발하지 않아 성능이 좋아짐 ==> 반정규화

   : 그 다음 결론

   + 내 생각엔, 데이터를 관리할때 상황에 맞게 고려하는 것이 최선. 내가 가진 데이터 파악이 우선

   + 해결을 위해 클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션 등을 검토하는 것도 성능해결에 큰 도움이 됨!

     + 클러스터링

       : 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장해버림

       : 이렇게 하면 조회 할때 인접한 블록을 연속적으로 읽어 성능적이 부분에서 향상함.

     + 파티션 기법

       : DB 파티션을 사용해 테이블을 분할함.

       : 논리적으로는 하나의 테이블이지만 실제론 여러 개의 데이터 파일에 분산되어 저장됨

       : 파티션 종류는 Range, List, Hash, COmposite 가 있으나 자세한 공부는 추후에,

       : 장점은 데이터가 분할되어 있어서 IO 성능의 향상, 각 파티션을 독립적으로 백업/복구 용이, 데이터 조회 할때 Access 범위가 줄어서 성능 향상된다.